# 从实模式到保护模式

## 预备知识

### 程序 = 数据 + 指令

无论是操作系统还是运行在操作系统上的软件, 对于计算机来说他们都是程序。而程序的组成我们可以简单的理解为：数据加上指令就是程序。当一个程序被从硬盘加载到内存后, CPU 从内存读取程序中的指令执行, 执行过
程中需要从内存中读取程序的数据, 配合指令计算出结果之后还需要放回到内存中。这就是简化后的程序执行过程。

### 如何从内存读取指令和数据

x86 使用"段基址 + 偏移量"的方式来读写内存。

#### 为什么有个"段"字

有人可能会问"段基址"里面的"段"代表什么呢？ 前面说了, 程序是由数据和指令组成的, 一个程序要运行就先要加载到内存中。而程序中的数据和指令是两个相互独立的部分, CPU 从内存读取他们的时候也是将他们看作是不
同的"段"。这里还要插一句, 程序中的数据还要分很多种类型, 所以 CPU 针对一个程序的不同部分准备了 4 个寄存器来分别存储他们的"段基址"。这 4 个寄存器分别是用于程序指令的 CS 代码段寄存器、用于程序数据的 DS 数据段寄存器、用于程序堆栈（也是数据的一种）的 SS 堆栈段寄存器和 ES 附加段寄存器（也是数据的一种）。

有了这 4 个寄存器存储"基地址"（数据的存放起始点）, 再配合"偏移量" CPU 就可以从内存读写数据和指令了。例如 CPU 在从内存中读取一个程序的指令准备执行的时候就可以说："从 CS 指向的地方开始向后读取 2 个位置", 内存收到 CPU 给的"指路信息"后就会把相应位置的指令发给 CPU, CPU 拿到指令就可以开始执行了。

#### “段基址” + “偏移量” 寻址方式的由来

了解了 x86 的内存寻址方式, 不禁要问：为什么要这么设计？ 这得从英特尔的 8086 CPU 开始讲起。我们有时说起计算机硬件配置的时候经常会说：我的电脑是 32 位的。这里的 32 位起始指的是 CPU 内部的数据总线宽度，也叫 ALU（算数逻辑单元）的宽度。说白了就是 CPU 一次性传递数据的宽度。

英特尔的 8086 CPU 是 16 位的, 如果直接用来表示内存地址的话, 16 位最大可以表示的内存地址是 216 = 65536 个地址, 每个地址代表一字节的内存数据的话, 16 位最多只能支持 64KB 内存，这显然是不够用的。
于是英特尔在保持数据线宽为 16 位的同时将地址线的宽度增大到 20 位, 也就是说内存地址是 20 位的, 这样就可以拥有 220 = 1048576 个地址, 最多支持 1MB 的内存, 当时的人们认为这样就足够了。

现在问题来了, 16 位的数据线宽（寄存器自然也是 16 位的）如何能表示 20 位的地址呢? 答案是用两个 16 位的寄存器来表示。这就是"段基址" + "偏移量"寻址方式的由来。

一个 16 位的寄存器来表示"段基址"（CS、DS、SS、ES四个寄存器）, 具体的做法是先将 16 位的段基址左移 4 位, 然后加上 16 位的偏移量最终得到 20 位的内存地址送入地址线。

#### 地址卷绕

#### 向下兼容的现代 x86 计算机

8086 的年代已经远去。现在的 x86 已早经是 32 位的了（目前 32 位基本已经没有了，64 位是主流了）。但无论位数如何增加，寻址能力如何增大，x86 一直保持着向下兼容的良好传统。即便是当初为 8086 这种 16 位机器写的软件或操作系统（如 DOS）仍能够在现在的 x86 计算机上顺利运行。

那么这种良好的向下兼容性是如何实现的呢？ 答案是："开关"

现代的 x86 计算机, 无论你是 32 位的还是 64 位的, 在开机的那一刻 CPU 都是以模拟 16 位模式运行的, 地址卷绕机制也是有效的, 所以无论你的电脑内存有多大, 开机的时候 CPU 的寻址能力只有 1MB，就好像回到 8086 时代一样。

那么什么时候才结束 CPU 的 16 位模式运行呢？ 这由你（操作系统）说了算, 现代的计算机都有个"开关"叫 A20 gate, 开机的时候 A20 gate 是关闭的, CPU 以 16 位模式运行, 当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。

#### 再说说把程序加载到内存

我们编写程序代码，编译器将我们的程序代码变成 CPU 可以理解的指令（二进制可执行程序）。在运行我们写的程序前, 需要将程序先加载进内存, 而我们的程序应该加载到内存的什么位置这应该是由操作系统来负责的，
我们程序本身是不能决定这一切的。

这里就产生了一个“矛盾”。在程序真正运行前我们是不知道我们会被放在内存的什么地方，但是我们的程序本身还有数据，代码也含有对数据的访问（例如我们的代码中使用的各种变量），我们不知道我们的数据会被操作系
统放在哪，但我们还要在代码里写访问这些数据的逻辑，这是一个矛盾，要怎么办？

解决上述矛盾的办法就是使用相对地址访问。我们的程序在运行前不知道会被操作系统放在内存的什么地方，所以我们在编写程序的时候会做个假设，假设我们的程序会被放在从内存地址 N 开始向后的地方。这个时候我们的程序在访问我们的变量时都继续这个假设，加入我们想要读取我们的变量 a 时, 我们就编写指令说我们要访问 N + X 的内存地址，那里存放着我们的变量 a，当然这些假设和生成每个数据的相对访问地址的工作都由编译器代劳了，对于我们程序的编写来说不用为这些事情而烦恼。

所以我们的每一个程序都会基于一个统一的假设：我们会被从内存地址 N 开始放置, 至于到真正运行时这个 N 对应的内存地址具体是多少无所谓，因为我们对我们程序数据的访问都是相对于 N 的偏移。

#### 程序是“假设”的，操作系统要动“真格”的

上面说了, 所有的程序都基于一个相同的“假设”，但是当程序真正运行的时候，操作系统将程序加载到内存时就不能对程序的这个“假设”听之任之了。当操作系统把程序放置到真正的内存位置后，程序运行起来，程序基于假设 N + X 计算出的内存地址就需要操作系统“翻译”成真正的内存地址后才能真的从内存中读取到想要的数据，而这个“翻译”的过程就需要操作系统和 CPU 来配合实现了。

程序基于“假设”计算出的地址叫做“虚拟地址”也叫做“逻辑地址”（他们是一样的，只是叫法不同），与之对应的内存的真实地址叫做“物理地址”，从“虚拟地址”到“物理地址”的转换是通过一个叫做 MMU（内存管理单元）的硬件实现的，当然这里还少不了操作系统的配合。

#### 实模式与保护模式

罗马不是一天建成的。上面所说的系统硬件和操作系统配合建立的“智能”、“安全”、“高效”的运行环境也是后来才逐渐完善的。所以为了区分这两种环境，在“智能”、“安全”、“高效”的运行环境建立之前计算机是运行在“实模式”下的，在“实模式”下没有“虚拟地址”到“物理地址”的转换，“虚拟地址”就相当于是“物理地址”，而想要这些特性就需要对应的把计算机的运行环境切换到“保护模式”下。

就像之前我们讲到的 A20 gate 从 1MB 的内存寻址模式切换到更大的寻址能力一样。x86 架构的计算机为了向下兼容，开机的时候不仅运行在 1MB 内存寻址环境下，这时候也是运行在“实模式”环境下的。同样有一个开关控制着从“实模式”到“保护模式”的切换，这个开关叫“控制寄存器”。

#### 保护模式下的分段与分页

"保护模式"是由硬件和操作系统配合来提供的。"保护模式"涉及的知识非常多, 不仅仅只有对内存的管理, 还有诸如进程管理、硬件管理等诸多方面, 这里只简单介绍一下"保护模式"下的内存管理。

保护模式实现的两种内存管理方式：分段式和分页式。分页式是目前主流操作系统（Windows、Linux、FreeBSD等）所采取的内存管理方式

“分页式”技术的出现要比“分段式”晚一些，碰上 x86 这样历史悠久的硬件架构就不得不再提“向下兼容”了。所以 x86 的分页式的实现是继续分段式基础上的。所以想要在 x86 上建立起分页式的内存管理就先要建立分段式内存管理，分页式我们暂且不说，先说说分段式。

分段式简单来说就是将内存规划出不同的“片段”来分配给不同的程序（也包含操作系统自己）使用。分页式则是将内存规划成大小相同的“页”，再将这些页分配给各个程序使用。

这里有两个“段”字非常让人容易迷糊。分段式里的段与之前讲过的“段基址”完全是两码事儿。实模式下的段寄存器里的“段基址”实际上还可以算作内存物理地址, 它指向的是内存中的一个位置，而在分段式的保护模式下段寄存
器里的"段基址"的意义已经发生里改变, 它不再是内存的物理地址，而是指向一个内存分段的段索引。

在分段模式下，内存被划分为很多个片段, 程序数据以及指令就放在这些片段中, 当要读取内存中具体的数据时, 首先要直到这个数据在哪个片段里, 这时段寄存器里的段基址指向某一个内存片段的下标，而这时的“偏移量”则相应的表示为具体的数据在它所在的内存“片段”里的偏移量。


### 预备知识总结

这里我们总结一下上面介绍的预备知识，来说说作为一个操作系统在计算机启动后到底应该做些什么

1. 计算机开机，运行环境为 1MB 寻址限制带“卷绕”机制
2. 打开 A20 gate 让计算机突破 1MB 寻址限制
3. 在内存中建立 GDT 全局描述符表，并将建立好的 GDT 表的位置和大小告诉 CPU
4. 设置控制寄存器 CR0, 进入保护模式
5. 按照保护模式的内存寻址方式继续执行


## 从 Makefile 开始

从一个操作系统的角度来说, xv6 的代码量并不大, 总共不到一万行, 分散在众多的源文件中。一上来可能觉得很迷茫, 这么多文件, 该从哪个开始看起? Makefile 则是这些文件的“目录”, 通过它可以很容易找到头绪。

从 Makefile 中可以看到 xv6.img 的生成条件：

`
xv6.img: bootblock kernel fs.img
  dd if=/dev/zero of=xv6.img count=10000
  dd if=bootblock of=xv6.img conv=notrunc
  dd if=kernel of=xv6.img seek=1 conv=notrunc
`

fs.img 这里暂且不说, 通过字面不难看出 bootblock 应该是系统一开始引导阶段的逻辑, kernel 当然就是内核了。所以第一步先研究 bootblock。我们接着在 Makefile 里找 bootblock 的生成条件：

`
bootblock: bootasm.S bootmain.c
  $(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
  $(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
  $(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
  $(OBJDUMP) -S bootblock.o > bootblock.asm
  $(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
  ./sign.pl bootblock
`

bootblock 的生成只需要两个文件, 一个汇编一个 C 源码。那我们就准备讲讲 bootasm.S 文件了。

### x86 的启动

看具体的代码前先说说 x86 架构开机引导的相关知识。从给 x86 通电的一刻开始, CPU 执行的第一段指令是 BIOS 固化在 ROM 上的代码, 这个过程是硬件定死的规矩, 就是这样。

而 BIOS 在硬件自检完成后（你会听到“滴”的一声）会根据你在 BIOS 里设置的启动顺序（硬盘、光驱、USB）读取每个引导设备的第一个扇区 512 字节的内容, 并判断这段内容的最后 2 字节是否为 0xAA55, 如果
是说明这个设备是可引导的, 于是就将这 512 字节的内容放到内存的 0x7C00 位置, 然后告诉 CPU 去执行这个位置的指令。这个过程同样是硬件定死的规矩, 就是这样。

有了上面的介绍我们再回到 xv6 如果你看一下编译生成的 bootblock 二进制文件，你会惊喜的发现它的文件大小刚好是 512 字节。

`-a---          2022/11/14    21:32            512 bootblock`


用十六进制编辑器打开 bootblock 这个二进制文件, 你又会发现这个 512 字节的文件的最后两字节正好是 0xAA55。

再回过头看上面 Makefile 中 xv6.img 生成条件的代码中也可以看出 xv6.img 就是通过 dd 命令将编译好的 bootblock 和 kernel 拼接而成, 这也再一次印证了 bootblock 是负责引导逻辑的结论。

有了这个结论, 我们可以开始“放心大胆”的开始看 bootasm.S 这个汇编源文件的代码了。

### bootasm.S 文件

看 bootasm.S 文件需要你有一定的汇编基础。

还是再看一眼 Makefile 里 bootblock 生成那段有这么一句

`$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o`

这段说明 bootblock 的代码段加载到内存 0x7C00 处, 代码从 start 处开始执行（可以理解为相当于 C 中的 main 这样的入口函数）。所以 bootasm.S 一上来就是入口 start

start:
  cli                         # BIOS enabled interrupts; disable
  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -> Data Segment
  movw    %ax,%es             # -> Extra Segment
  movw    %ax,%ss             # -> Stack Segment

先讲 start：下面的这 5 行代码。

1. cli 指令关闭了中断响应, 意味着从这一刻开始你的计算机将不再响应任何中断事件（比如这时候你敲个键盘点个鼠标啥的, CPU 就不再理你了）。之所以要关闭中断响应是因为要保证引导代码的顺利执行（总不能执行
   到一半被 CPU 给中断了吧，那直接就挂了）。
2. 接下来的 4 行代码显示用异或将 %ax 寄存器的值置成 0， 然后在用 %ax 寄存器的值将 %ds、%es、%ss 三个寄存器的值全部置 0， 相当于初始化了
3. 然后我们再看 .code16 这句。这告诉 CPU 我们目前是在 16 位模式下执行代码，此时内存寻址能力只有 1MB, 并且是“实模式”下


### 打开 A20 gate

在预备知识那段我们讲里要想计算机突破 1MB 内存寻址的限制我们要把 A20 gate 打开，我们接着往下看 xv6 bootasm.S 的代码。在初始化好寄存器后，xv6 bootasm.S 接下来要做的事情就是打开 A20 gate 突破
 1MB 内存寻址的限制。

控制 A20 gate 的方法有 3 种:

804x 键盘控制器法
Fast A20 法
BIOS 中断法

xv6 用了第一种 804x 键盘控制器法, 这也是最古老且效率最慢的一种。当然因为硬件的不同, 这三种方法可能不会被硬件都支持, 正确的做法应该是这三种都尝试一下, 每尝试一个就验证一下 A20 gate 是否被正确打开以
保证兼容各种硬件。像诸如 Linux 这样的操作系统就把三种方法的实现都做好里, 并且加上了验证机制。


### xv6 准备 GDT

在进入保护模式前需要将 GDT 准备好。什么是 GDT ？ 它的中文名称叫“全局描述符表”, 想要在“保护模式”下对内存进行寻址就先要有 GDT, GDT 表里的每一项叫做“段描述符”, 用来记录每个内存分段的一些属性信息, 每个“段描述符”占 8 字节, 我们先来看一眼这个段描述符的具体结构：


31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
            基地址	            G	DB	XX	AA	Limit	         P	 DPL	 S	E	ED	RW	A	基地址

                      基地址	                                                               Limit

三块“基地址”组装起来正好就是 32 位的段起始内存地址，两块 Limit 组成该内存分段的长度，接下来依次解释一下其他位所代表的意义：


P:       0 本段不在内存中
DPL:     访问该段内存所需权限等级 00 — 11，0为最大权限级别
S:       1 代表数据段、代码段或堆栈段，0 代表系统段如中断门或调用门
E:       1 代表代码段，可执行标记，0 代表数据段
ED:      0 代表忽略特权级，1 代表遵守特权级
RW:      如果是数据段（E=0）则1 代表可写入，0 代表只读；
         如果是代码段（E=1）则1 代表可读取，0 代表不可读取
A:       1 表示该段内存访问过，0 表示没有被访问过
G:       1 表示 20 位段界限单位是 4KB，最大长度 4GB；
         0 表示 20 位段界限单位是 1 字节，最大长度 1MB
DB:      1 表示地址和操作数是 32 位，0 表示地址和操作数是 16 位
XX:      保留位永远是 0
AA:      给系统提供的保留位

有了上述的解释，我们再来看看 xv6 是怎样准备自己的 GDT 的，代码在 bootasm.S 文件最底部：

gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg

这里用到了几个宏，具体的宏定义在 asm.h 文件中，为了方便大家直观的感受一下 xv6 的 GDT 我把宏计算出来的值直接翻译过来，代码应该是下面这个样子：

gdt:
  .word 0, 0;
  .byte 0, 0, 0, 0                             # 空
  .word 0xffff, 0x0000;
  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段
  .word 0xffff, 0x0000;
  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段


然后我们再把代码段和数据段的段描述符具体每一位的对应值表展示出来，首先是代码段：

31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
基地址	                         G	DB	XX	AA	Limit	          P	DPL	S	E	ED	RW	A	基地址
0x00	                        1	1	0	0	0xf	             1	00	1	1	0	1	0	0x00
                          基地址	                                                  Limit
                          0x0000	                                                 0xffff



然后是数据段：


31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
基地址	                         G	DB	XX	AA	Limit	         P	DPL	S	E	ED	RW	A	基地址
0x00	                        1	1	0	0	0xf	            1	00	1	0	0	1	0	0x00
                                    基地址	                                          Limit
                                    0x0000	                                         0xffff

首先说说这两个内存段的共同点，DB = 1，G = 1，基地址都是 0x00000000, 内存分段长度都是 0xfffff, 这说明他们都是用于 32 位寻址，所使用的内存是从 0 开始到 4GB 结束（全部内存）。这里是这么算出来的, 段
长度是 0xfffff = 2^20, G = 1 表示段界限单位是 4k, 所以 4k * 220 = 4GB。

当然作为一款教学为目的的操作系统，xv6 这里的 GDT 设置还是以简单容易理解为目的。诸如“权限位”这样的安全机制就直接被忽略了, 而对内存的规划也没有做到真正的“分段”, 而是代码段和数据段都启用了从 0 到 4GB 的全部内存寻址。其实这种内存规划方法叫做“平坦内存模型”, 即便是 Linux 也是用的这样的方式规划内存的，并没有做到真正的“分段”。这是因为 x86 的分页机制是基于分段的, Linux 选用了更先进的分页机制来管理内存, 所以在分段这里只是走一个必要的形式罢了。而 xv6 后面到底是否也启用了分页机制，我们目前还不得而知。

### xv6 正式进入保护模式

GDT 也搞定了, 接下来我们就要把我们刚刚在内存中设定好的 GDT 的位置告诉 CPU，然后就“万事俱备，只欠东风”了。






## Ref

1. [xv6](http://leenjewel.github.io/blog/2014/07/29/%5B%28xue-xi-xv6%29%5D-cong-shi-mo-shi-dao-bao-hu-mo-shi/)


