# 从实模式到保护模式

## 预备知识

### 程序 = 数据 + 指令

无论是操作系统还是运行在操作系统上的软件, 对于计算机来说他们都是程序。而程序的组成我们可以简单的理解为：数据加上指令就是程序。当一个程序被从硬盘加载到内存后, CPU 从内存读取程序中的指令执行, 执行过
程中需要从内存中读取程序的数据, 配合指令计算出结果之后还需要放回到内存中。这就是简化后的程序执行过程。

### 如何从内存读取指令和数据

x86 使用"段基址 + 偏移量"的方式来读写内存。

#### 为什么有个"段"字

有人可能会问"段基址"里面的"段"代表什么呢？ 前面说了, 程序是由数据和指令组成的, 一个程序要运行就先要加载到内存中。而程序中的数据和指令是两个相互独立的部分, CPU 从内存读取他们的时候也是将他们看作是不
同的"段"。这里还要插一句, 程序中的数据还要分很多种类型, 所以 CPU 针对一个程序的不同部分准备了 4 个寄存器来分别存储他们的"段基址"。这 4 个寄存器分别是用于程序指令的 CS 代码段寄存器、用于程序数据的 DS 数据段寄存器、用于程序堆栈（也是数据的一种）的 SS 堆栈段寄存器和 ES 附加段寄存器（也是数据的一种）。

有了这 4 个寄存器存储"基地址"（数据的存放起始点）, 再配合"偏移量" CPU 就可以从内存读写数据和指令了。例如 CPU 在从内存中读取一个程序的指令准备执行的时候就可以说："从 CS 指向的地方开始向后读取 2 个位置", 内存收到 CPU 给的"指路信息"后就会把相应位置的指令发给 CPU, CPU 拿到指令就可以开始执行了。

#### “段基址” + “偏移量” 寻址方式的由来

了解了 x86 的内存寻址方式, 不禁要问：为什么要这么设计？ 这得从英特尔的 8086 CPU 开始讲起。我们有时说起计算机硬件配置的时候经常会说：我的电脑是 32 位的。这里的 32 位起始指的是 CPU 内部的数据总线宽度，也叫 ALU（算数逻辑单元）的宽度。说白了就是 CPU 一次性传递数据的宽度。

英特尔的 8086 CPU 是 16 位的, 如果直接用来表示内存地址的话, 16 位最大可以表示的内存地址是 216 = 65536 个地址, 每个地址代表一字节的内存数据的话, 16 位最多只能支持 64KB 内存，这显然是不够用的。
于是英特尔在保持数据线宽为 16 位的同时将地址线的宽度增大到 20 位, 也就是说内存地址是 20 位的, 这样就可以拥有 220 = 1048576 个地址, 最多支持 1MB 的内存, 当时的人们认为这样就足够了。

现在问题来了, 16 位的数据线宽（寄存器自然也是 16 位的）如何能表示 20 位的地址呢? 答案是用两个 16 位的寄存器来表示。这就是"段基址" + "偏移量"寻址方式的由来。

一个 16 位的寄存器来表示"段基址"（CS、DS、SS、ES四个寄存器）, 具体的做法是先将 16 位的段基址左移 4 位, 然后加上 16 位的偏移量最终得到 20 位的内存地址送入地址线。

#### 地址卷绕

#### 向下兼容的现代 x86 计算机

8086 的年代已经远去。现在的 x86 已早经是 32 位的了（目前 32 位基本已经没有了，64 位是主流了）。但无论位数如何增加，寻址能力如何增大，x86 一直保持着向下兼容的良好传统。即便是当初为 8086 这种 16 位机器写的软件或操作系统（如 DOS）仍能够在现在的 x86 计算机上顺利运行。

那么这种良好的向下兼容性是如何实现的呢？ 答案是："开关"

现代的 x86 计算机, 无论你是 32 位的还是 64 位的, 在开机的那一刻 CPU 都是以模拟 16 位模式运行的, 地址卷绕机制也是有效的, 所以无论你的电脑内存有多大, 开机的时候 CPU 的寻址能力只有 1MB，就好像回到 8086 时代一样。

那么什么时候才结束 CPU 的 16 位模式运行呢？ 这由你（操作系统）说了算, 现代的计算机都有个"开关"叫 A20 gate, 开机的时候 A20 gate 是关闭的, CPU 以 16 位模式运行, 当 A20 gate 打开的时候“卷绕”机制失效，内存寻址突破 1MB 限制，我们就可以切换到正常的模式下运行了。

#### 再说说把程序加载到内存

我们编写程序代码，编译器将我们的程序代码变成 CPU 可以理解的指令（二进制可执行程序）。在运行我们写的程序前, 需要将程序先加载进内存, 而我们的程序应该加载到内存的什么位置这应该是由操作系统来负责的，
我们程序本身是不能决定这一切的。

这里就产生了一个“矛盾”。在程序真正运行前我们是不知道我们会被放在内存的什么地方，但是我们的程序本身还有数据，代码也含有对数据的访问（例如我们的代码中使用的各种变量），我们不知道我们的数据会被操作系
统放在哪，但我们还要在代码里写访问这些数据的逻辑，这是一个矛盾，要怎么办？

解决上述矛盾的办法就是使用相对地址访问。我们的程序在运行前不知道会被操作系统放在内存的什么地方，所以我们在编写程序的时候会做个假设，假设我们的程序会被放在从内存地址 N 开始向后的地方。这个时候我们的程序在访问我们的变量时都继续这个假设，加入我们想要读取我们的变量 a 时, 我们就编写指令说我们要访问 N + X 的内存地址，那里存放着我们的变量 a，当然这些假设和生成每个数据的相对访问地址的工作都由编译器代劳了，对于我们程序的编写来说不用为这些事情而烦恼。

所以我们的每一个程序都会基于一个统一的假设：我们会被从内存地址 N 开始放置, 至于到真正运行时这个 N 对应的内存地址具体是多少无所谓，因为我们对我们程序数据的访问都是相对于 N 的偏移。

#### 程序是“假设”的，操作系统要动“真格”的

上面说了, 所有的程序都基于一个相同的“假设”，但是当程序真正运行的时候，操作系统将程序加载到内存时就不能对程序的这个“假设”听之任之了。当操作系统把程序放置到真正的内存位置后，程序运行起来，程序基于假设 N + X 计算出的内存地址就需要操作系统“翻译”成真正的内存地址后才能真的从内存中读取到想要的数据，而这个“翻译”的过程就需要操作系统和 CPU 来配合实现了。

程序基于“假设”计算出的地址叫做“虚拟地址”也叫做“逻辑地址”（他们是一样的，只是叫法不同），与之对应的内存的真实地址叫做“物理地址”，从“虚拟地址”到“物理地址”的转换是通过一个叫做 MMU（内存管理单元）的硬件实现的，当然这里还少不了操作系统的配合。

#### 实模式与保护模式

罗马不是一天建成的。上面所说的系统硬件和操作系统配合建立的“智能”、“安全”、“高效”的运行环境也是后来才逐渐完善的。所以为了区分这两种环境，在“智能”、“安全”、“高效”的运行环境建立之前计算机是运行在“实模式”下的，在“实模式”下没有“虚拟地址”到“物理地址”的转换，“虚拟地址”就相当于是“物理地址”，而想要这些特性就需要对应的把计算机的运行环境切换到“保护模式”下。

就像之前我们讲到的 A20 gate 从 1MB 的内存寻址模式切换到更大的寻址能力一样。x86 架构的计算机为了向下兼容，开机的时候不仅运行在 1MB 内存寻址环境下，这时候也是运行在“实模式”环境下的。同样有一个开关控制着从“实模式”到“保护模式”的切换，这个开关叫“控制寄存器”。

#### 保护模式下的分段与分页

"保护模式"是由硬件和操作系统配合来提供的。"保护模式"涉及的知识非常多, 不仅仅只有对内存的管理, 还有诸如进程管理、硬件管理等诸多方面, 这里只简单介绍一下"保护模式"下的内存管理。

保护模式实现的两种内存管理方式：分段式和分页式。分页式是目前主流操作系统（Windows、Linux、FreeBSD等）所采取的内存管理方式

“分页式”技术的出现要比“分段式”晚一些，碰上 x86 这样历史悠久的硬件架构就不得不再提“向下兼容”了。所以 x86 的分页式的实现是继续分段式基础上的。所以想要在 x86 上建立起分页式的内存管理就先要建立分段式内存管理，分页式我们暂且不说，先说说分段式。

分段式简单来说就是将内存规划出不同的“片段”来分配给不同的程序（也包含操作系统自己）使用。分页式则是将内存规划成大小相同的“页”，再将这些页分配给各个程序使用。

这里有两个“段”字非常让人容易迷糊。分段式里的段与之前讲过的“段基址”完全是两码事儿。实模式下的段寄存器里的“段基址”实际上还可以算作内存物理地址, 它指向的是内存中的一个位置，而在分段式的保护模式下段寄存
器里的"段基址"的意义已经发生里改变, 它不再是内存的物理地址，而是指向一个内存分段的段索引。

在分段模式下，内存被划分为很多个片段, 程序数据以及指令就放在这些片段中, 当要读取内存中具体的数据时, 首先要直到这个数据在哪个片段里, 这时段寄存器里的段基址指向某一个内存片段的下标，而这时的“偏移量”则相应的表示为具体的数据在它所在的内存“片段”里的偏移量。


### 预备知识总结

这里我们总结一下上面介绍的预备知识，来说说作为一个操作系统在计算机启动后到底应该做些什么

1. 计算机开机，运行环境为 1MB 寻址限制带“卷绕”机制
2. 打开 A20 gate 让计算机突破 1MB 寻址限制
3. 在内存中建立 GDT 全局描述符表，并将建立好的 GDT 表的位置和大小告诉 CPU
4. 设置控制寄存器 CR0, 进入保护模式
5. 按照保护模式的内存寻址方式继续执行